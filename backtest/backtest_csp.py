from typing import Dict, List
import pandas as pd

from backtest.backtest_base import BacktestBase
from backtest.event import Event, CashFlowChange, UpdatePortfolio
from .utils.constant import FREQUENCY
from .utils.logger import logger


class BacktestCSP(BacktestBase):
    def __init__(self, history_data_path: str, instruments: Dict, frequency: FREQUENCY, start_date: str,
                 end_date: str, initial_cash: float = 0, **kwargs) -> None:

        """
        Initializes the backtesting environment for strategies involving complex instruments.

        Args:
            history_data_path: path to directory that contains all market data. The path needs to be combined with symbol and instrument type.
            frequency: The frequency of the backtest data.
            start_date: The start date of the backtest.
            end_date: The end date of the backtest.
            initial_cash: The starting cash balance for the portfolio.
        """
        super().__init__(history_data_path, instruments, frequency, start_date, end_date, **kwargs)



    def run_backtest(self, time_ordered_events: List[Event]) -> None:
        """
        Simulates portfolio performance by processing a chronological list of events.
        This method relies on the Portfolio class to handle the logic for all instrument types.
        
        Args:
            time_ordered_events: A list of events sorted by timestamp, generated by a strategy.
        """
        self.events = time_ordered_events
        logger.info(f"Starting backtest with {len(self.events)} events.")
        
        # Take an initial snapshot of the portfolio before any events occur
        self.portfolio_snapshots.append(self.portfolio.get_snapshot())
        
        for event in self.events:
            # The order of these checks matters. A daily UpdatePortfolio should typically
            # be the last event for a given day to reflect the end-of-day values.
            
            if isinstance(event, CashFlowChange):
                self.portfolio.add_cash_flow(event.change_amount)
                logger.info(f"{event.ts}: Cash flow change of {event.change_amount}. New balance: {self.portfolio.cash_balance}")

            elif isinstance(event, FilledOrder):
                # The portfolio's fill_order method handles all the logic for
                # stocks and options, thanks to the Position class.
                self.portfolio.fill_order(event)

            elif isinstance(event, UpdatePortfolio):
                # The portfolio's update method marks all positions (stocks and options) to market.
                self.portfolio.update_portfolio(event.prices)
                logger.info(f"{event.ts}: Portfolio value updated to {self.portfolio.portfolio_value:.2f}")

            # You can add handlers for other event types like LimitOrder here if needed
            elif isinstance(event, Event):
                raise NotImplementedError(f"Event type {type(event)} is not supported by this backtester.")
            
            # Take a snapshot of the portfolio's state after each event is processed
            self.portfolio_snapshots.append(self.portfolio.get_snapshot())
        
        logger.info("Backtest finished.")
        logger.info(f"Final portfolio value: {self.portfolio.portfolio_value:.2f}")

    def export_filled_orders(self, file_path: str = "csp_backtest_orders.xlsx") -> None:
        """Exports all filled orders from the backtest to an Excel file."""
        if not self.events:
            logger.error("No events were processed, cannot export orders.")
            return

        filled_orders = [event for event in self.events if isinstance(event, FilledOrder)]
        
        if not filled_orders:
            logger.warning("No FilledOrder events found to export.")
            return

        data = [{
            "filled_timestamp": order.filled_date,
            "instrument_symbol": order.instrument.symbol,
            "instrument_type": order.instrument.type.value,
            "side": order.side.name,
            "quantity": order.quantity,
            "filled_price": order.filled_price,
            "order_value": order.order_value,
        } for order in filled_orders]

        df = pd.DataFrame(data)
        df.to_excel(file_path, index=False)
        logger.info(f"Successfully exported {len(df)} filled orders to {file_path}")